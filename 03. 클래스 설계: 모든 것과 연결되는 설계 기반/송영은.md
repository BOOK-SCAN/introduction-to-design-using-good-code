# 📌 Contents


좋은 클래스 구성과 디자인 패턴

## 📌 클래스 단위로 잘 동작하게 설계하기

- 클래스 하나로도 잘 동작할 수 있게 설계해야 한다
- 복잡한 초기 설정을 하지 않아도 곧바로 사용할 수 있게 만들어야 한다
- 최소한의 조작 방법(메서드)만 외부에 제공해야 함

### 클래스 구성 요소

- 인스턴스 변수
- 인스턴스 변수에 잘못된 값이 할당되지 않게 막고, 정상적으로 조작하는 메서드

### 좋은 클래스 구성

- 반드시 메서드와 인스턴스 변수를 함께 사용해야 함.(다만 목적에 따라 예외적으로 이러한 구성이 좋을 때도 있음)

ex) GoodClss

field : type

method() : type

- 왜?
    - 데이터 클래스는 일반적으로 인스턴스 변수를 조작하는 로직이 다른 클래스에 구현되어 있음
    - 따라서 연관성을 알아채기 어려움
    - 인스턴스를 생성하더라도 인스턴스 변수들은 아직 유효하지 않은 상태이므로, 초기화를 따로 해줘야 함
- 데이터 클래스는 다른 클래스가 여러 가지를 준비해 줘야만 잘 작동하고, 혼자서는 아무것도 할 수 없는 미성숙한 클래스임.

### 자기 방어 임무

- 클래스는 스스로 자기 방어 임무를 수행할 수 있어야 소프트웨어의 품질을 높이는 데 도움이 됨
- 데이터 클래스에 자기 방어 임무를 부여하여 다른 클래스에 맡기던 일을 스스로 설계할 수 있게 설계하면 됨

## 📌 성숙한 클래스로 성장시키는 설계 기법

```jsx
//금액을 나타내는 클래스
import java.util.Currency;

class Money{
	int amount;         //금액
	Currency currency;  //통화 단위
}
```

### 생성자로 확실하게 정상적인 값 설정하기

- 로우 데이터 객체(초기화되지 않은 상태)를 방지하려면, 적절한 초기화 로직을 생성자에 구현하면 됨

```jsx
//생성자에서 초기화하기
class Money{
	int amount;
	Currency currency;
	
	Money(int amount, Currency currency){
		this.amount = amount;
		this.currency = currency;
	}
}
```

- 위 코드처럼 하면 인스턴스 변수가 무조건 초기화 됨.
- 하지만 매개변수로 잘못된 값이 전달될 수 있음
- 잘못된 값이 유입되지 못하게 유효성 검사를 생성자 내부에 정의해야 함

```jsx
//생성자에서 유효성 검사하기
Money(int amount, Currency currency){
	if(amount < 0){ //amount는 0 이상의 정수
		throw new IllegalArgumentException("금액은 0 이상의 값을 지정해주세요");
	}
	if(currency == null){ //currency는 null 이외의 것
		throw new NullPointerException("통화 단위를 지정해 주세요.");
	}
	this.amount = amount;
	this.currency = currency;
}
```

### 계산 로직도 데이터를 가진 쪽에 구현하기

- ‘응집도가 낮은 구조’ : 데이터와 데이터를 조작하는 로직이 분리되어 있는 구조
- 문제를 막으려면 다른 클래스에 맡겼던 일을 스스로 할 수 있게 만들어야 함

```jsx
//Money 클래스에 금액을 추가하는 메서드 만들기
class Money{
	//생략
	void add(int other){
	amount += other;
	}
}
```

### 불변 변수로 만들어서 예상치 못한 동작 막기

```jsx
//인스턴스 변수를 계속해서 변경하는 경우
money.amount = originalPrice;
//생략
if(specialServiceAdded){
	money.add(additionalServiceFee);
	//생략
	if(seasonOffApplied){
		money.amount = seasonPrice();
	}
}
```

- 변수의 값이 계속 바뀌면 계속 신경써야 함.
- 신경쓰는 도중 의도치 않은 값을 할당할 수 있기 때문에
- 이를 막으려면, 인스턴스 변수를 불변으로 만듦.(final 수식자 사용)

```jsx
//final 붙여 불변 변수로 만들기
class Money{
	final int amonut;
	final Currency currency;
	
	Money(int amount, Currency currency){
	//생략
	this.amount = amount;
	this.currency = currency;
	}
}
```

- 인스턴스 변수에 final 수식자를 붙이면, 한 번만 할당 가능
- 변수 선언 시점 또는 생성자 안에서만 값 할당 가능. 이후에 재할당 불가

```jsx
//재할당 불가
Currency won = Currency.getInstance(Local.KOREA);
Money money = new Money(100,won);
money.amount = -200;  //컴파일 오류
```

### 변경하고 싶다면 새로운 인스턴스 만들기

- 불변이어도 값 변경 가능
- how?
    - 인스턴스 변수의 내용을 변경하는 것이 아니라, 변경된 값을 가진 새로운 인스턴스를 만들어서 사용하면 됨

```jsx
//변경된 값을 가진 인스턴스 생성하기
class Money{
	//생략
	Money add(int other){
		int added = amount + other;
		return new Money(added, currency);
	}
}
```

- 합산 금액을 값으로 갖는 Money 인스턴스를 생성하고 리턴하는 로직
- 이렇게 하면 불변을 유지하면서 값을 변경할 수 있음

### 메서드 매개변수와 지역 변수도 불변으로 만들기

```jsx
//메서드 내부에서 매개변수 변경
void doSomething(int value){
	value = 100;
	
//final로 매개변수를 재할당하지 못하게 만들기
void doSomething(final int value){
	value = 100;  //컴파일 오류
	
//add 메서드의 매개변수도 final로 만들기
class Money{
	//생략
	Money add(final int other){
		int added = amount + other;
		return new Money(added, currency);
	}
}

//지역 변수도 불변으로 만들기
class Money{
	//생략
	Money add(final int other){
		final int added = amount + other;
		return new Money(added, currency);
	}
}
```

### 엉뚱한 값을 전달하지 않도록 하기

```jsx
//금액을 의미하지 않는 값을 전달하는 경우
final int ticketCount = 3;  //티켓의 수
money.add(ticketCount);

//Money 자료형만 받도록 메서드 수정하기
class Money{
	//생략
	Money add(final Money other){
		final int added = amount + other.amount;
		return new Money(added, currency);
	}
}
```

- 매개변수의 자료형을 int→ Money로 바꿈
- Money 이외의 자료형을 전달할 수 없음. 따라서 엉뚱한 값이 전달되는 상황 자체를 막을 수 있게 됨

- 기본 자료형(프로그래밍 언어가 표준적으로 제공하는 자료형) 위주로 사용하면 실수로 의미가 다른 값을 전달하기 쉬움

```jsx
//add 메서드를 추가로 개선하기
class Money{
	//생략
	Money add(final Money other){
		if(!currency.equals(other.currency)){
			throw new IllegalArgumentException("통화 단위가 다릅니다.");
		}
		final int added = amount + other.amount;
		return new Money(added, currency);
	}
}
```

### 의미 없는 메서드 추가하지 않기

- 시스템 사양에 필요하지 않은 메서드를 선의로 추가하면, 이후에 누군가 이를 무심코 사용했을 때 버그가 될 수 있음

## 📌 악마 퇴치 효과 검토하기

```jsx
//관련 로직을 응집해서 코드 수정 시 버그 발생이 어려워진 Money 클래스
import java.util.Currency;

class Money{
	final int amount;
	final Currency currency;
	
	Money(final int amount, final Currency currency){
		if(amount < 0){
			throw new IllegalArgumentException("금액은 0 이상의 값을 지정해주세요.");
		}
		if(currency == null){
			throw new NullPointerException("통화 단위를 지정해 주세요.");
		}
		this.amount = amount;
		this.currency = currency;
	}
	
	Money add(final Money other){
		if(!currency.equals(other.currency)){
			throw new IllegalArgumentException("통화 단위가 다릅니다.");
		}
		
		final int added = amount + other.amount;
		return new Money(added, currency);
	}
}
```

- 클래스 설계란?
    - 인스턴스 변수가 잘못된 상태에 빠지지 않게 하기 위한 구조를 만드는 것
- 응집도가 높은 구조
    - 로직이 한곳에 모여 있는 구조
- 캡슐화
    - ‘데이터’와 ‘그 데이터를 조작하는 로직’을 하나의 클래스로 묶고, 필요한 절차(메서드)만 외부에 공개하는 것

## 📌 프로그램 구조 문제 해결에 도우는 디자인 패턴

- 디자인 패턴?
    - 응집도가 높은 구조로 만들거나, 잘못된 상태로부터 프로그램을 방어하는 등 프로그램 구조를 개선하는 설계 방법

| 디자인 패턴 | 효과 |
| --- | --- |
| 완전 생성자 | 잘못된 상태로부터 보호함 |
| 값 객체 | 특정한 값과 관련된 로직의 응집도를 높임 |
| 전략 | 조건 분기를 줄이고, 로직 단순화 |
| 정책 | 조건 분기를 단순화하고, 더 자유롭게 만듦 |
| 일급 컬렉션 | 값 객체의 일종으로 컬렉션과 관련된 로직의 응집도를 높임 |
| 스프라우트 클래스 | 기존 로직을 변경하지 않고, 안전하게 새로운 기능 추가 |

### 완전 생성자

- 잘못된 상태로부터 클래스를 보호하기 위한 디자인 패턴
- 쓰레기 객체를 방지하기 위해 인스턴스 변수를 모두 초기화해야만 객체를 생성할 수 있게, 매개변수를 가진 생성자를 만들기
- 생성자 내부에서는 가드를 사용해서 잘못된 값이 들어오지 않게 만듦

### 값 객체

- 값을 클래스로 나타내는 디자인 패턴
- 다양한 값을 객체로 만들 수 있음 → 각각의 값과 로직을 응집도가 높은 구조로 만들 수 있음
- 다른 값이 섞이는 상황을 원천적으로 차단할 수 있음

값 객체 + 완전 생성자는 객체 지향 설계에서 폭넓게 사용되는 기법임!!

# ❓ Questions


### ❓ 디자인 패턴 설명이 부족한 것 같아요.

**디자인 패턴이란?**

개발하면서 발생하는 **반복적인 문제**들을 어떻게 해결할 것인지에 대한 **해결방안**으로 실제 현업에서 비즈니스 요구 사항을 프로그래밍으로 처리하면서 만들어진 다양한 해결책 중에서 많은 사람들이 인정한 **모범 사례**임.

**디자인 패턴 구조**

- 콘텍스트
    - 패턴이 적용될 수 있는 상황을 나타낸다.
- 문제
    - 패턴이 적용되어 해결될 필요가 있는 여러 디자인 이슈들을 기술한다.
    - 이때 여러 제약 사항과 영향력도 문제 해결을 위해 고려해야 한다.
- 해결
    - 문제를 해결하도록 설계를 구성하는 요소들과 그 요소들 사이의 관계, 책임, 협력 관계를 기술한다.
    - 해결은 반드시 구체적인 구현 방법이나 언어에 의존적이지 않으며 다양한 상황에 적용할 수 있는 일종의 템플릿이다.

- 전략 ~= 정책
    - 같은 문제를 해결하는 여러 알고리즘이 클래스별로 캡슐화되어 있고 이들이 필요할 때 교체할 수 있도록 함으로써 동일한 문제를 다른 알고리즘으로 해결할 수 있게 하는 디자인 패턴

[[디자인 패턴] 전략 패턴 (Strategy Pattern), 정책 패턴 (Policy Pattern)](https://wjddntjr555w.tistory.com/56)

- 일급 컬렉션
    - 컬렉션과 관련된 로직을 캡슐화하는 디자인 패턴
    - **Collection**을 **Wrapping** 하면서 그 외의 다른 멤버 변수가 없는 상태
    - 일급 컬렉션이 필요한 이유?
        - Collection 의 불변성 보장
        - 비지니스에 종속적인 자료구조
        - 값과 로직을 한 곳에서 관리

[일급 컬렉션(First Class Collection)을 사용하는 이유](https://velog.io/@yeseul/일급-컬렉션First-Class-Collection을-사용하는-이유)

- 스프라우트 클래스

뭔지 잘 모르겠습니당. 찾아도 안 나와요.
