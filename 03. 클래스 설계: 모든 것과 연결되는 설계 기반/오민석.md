# 📌 Contents
### 📌 잘 만들어진 클래스의 구성
> 1. 인스턴스 변수
> 2. 인스턴스 변수에 잘못된 값이 할당되지 않게 막고, 정상적으로 조작하는 메서드
- 위의 사항을 만족하기 위해 클래스는 자기방어 의무가 있습니다.
<br/>

### 📌 클래스를 성숙하게 하는 방법
- 생성자로 정상적인 값이 들어가게 합니다.
- 데이터가 있는 곳에 메서드를 구현하되 사용하는 메서드만 구현합니다.
- final을 활용하여 불변 변수로 만듭니다. 또 변경 시에는 새로운 인스턴스를 반환합니다.
<br/>

### 📌 OOP에서 넓게 사용하는 조합: 값 객체 + 완전 생성자
|이름 | 사용법 | 효과 |
| --- | --- | --- |
| 값 객체 | 값을 클래스로 만들고 메서드를 함께 구성하여 다른 값과 혼용되지 않도록 함  | 특정한 값과 관련된 로직의 응집도를 높임 |
| 완전 생성자 | 매개변수를 가지고 가드를 만들어 값을 안전하게 초기화하는 생성자를 만듦 | 잘못된 상태로부터 보호함 |
<br/>

# ❓ Questions
### ❓ final 키워드를 사용하면 변경할 수 없을까?
```
Class에서 final 키워드를 사용하면 변수를 변경하지 못한다는 것을 배웠습니다.
하지만 만약 내부에 들어간 변수가 객체라면 어떨까요?
즉, 새로운 메모리 주소가 할당되는 것이 아니라면 문제가 없는 것 아닐까요?
코드로 한번 확인해봅시다.
```
```java
class A {
    final int value1;
    final B value2;
    
    public A(int value1, B value2) {
        this.value1 = value1;
        this.value2 = value2;
    }
}

class B {
    int value3;
    
    public B(int value3) {
        this.value3 = value3;
    }
}

class Hello {
    public static void main(String[] args) {
        B b = new B(2);
        A a = new A(2, b);
        
        a.value2.value3 = 3;
        System.out.println(a.value2.value3);
    }
}
// output: 3
```
```
위의 코드에서 볼 수 있듯이, 객체라면 내부 변경이 가능합니다.
여기서 고민해봐야 할 점은 "어떻게 이를 막을 것인가?" 입니다.

1. Class B에서도 final 키워드를 사용한다.
2. private을 사용하고 setter를 필요시에 정의한다.

이와 같은 방식으로 변경을 제어한다면 더 나은 코드가 될 것 같네요.
```
<br/>

### ❓ 새로운 인스턴스를 반환하는 메서드에서 기존의 인스턴스는 어떻게 될까?
```
Java에서는 필요 없는 객체를 처리하기 위해 '가비지 컬렉션'이 진행됩니다.
그렇다면 이는 뭐고 어떻게 동작하는 걸까요?

'가비지 컬렉션'은 불필요한 메모리를 알아서 정리해주는 것입니다.
JVM의 Heap 영역은 2가지의 전제로 설계되었습니다.
1. 대부분의 객체는 금방 접근 불가능한 상태가 된다.
2. 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.
따라서 생존 기간에 따라 Heap을 Young(작고 빠름), Old(크고 느림) 총 2가지 영역으로 설계했습니다.
또한 Old 영역에서 참조하는 Young 영역의 객체는 카드 테이블에 저장하여 GC 대상인지를 확인합니다.
```
> 마치 cache와 memory 같은 방식이네요!
```
'가비지 컬렉션'은 다음의 동작 방식을 가집니다.
1. Stop the World
2. Mark and Sweep

1은 가비지 컬렉션을 위해 JVM이 애플리케이션 실행을 멈추는 작업입니다.
GC를 실행하는 쓰레드 제외 모든 쓰레드들이 작업이 중단됩니다.

2는 Mark, 사용되지 않는 메모리를 식별하는 작업과 Sweep 이를 해제하는 작업입니다.
GC는 스택의 모든 변수 혹은 접근 가능한 객체를 스캔하며 참조하는 객체를 탐색합니다.
그렇게 Mark 과정이 끝나면 Sweep 과정까지 한 후 마무리됩니다.
```
> 매우 큰 힙이나 느린 GC가 아니라면 중지는 매우 짧은 시간에 끝난다고 합니다!
<br/>

### ❓ static 변수는 그러면 사용하면 안 될까?
```
static 변수를 사용하려면 어떻게 악마를 대비해야 할까요?
디자인 패턴 중 static을 사용하는 패턴이 있음을 알고 있습니다.
이는 '싱글톤 패턴'입니다. 이를 보면서 디자인 패턴은 어떻게 해결했는지 알아봅시다! 

일단 static이란 모든 Class 내에 딱 하나만 정의가 되는 값입니다.
다시 말해 여러 번 생성이 될 필요가 없다는 뜻입니다.
그렇다면 코드로 확인해봅시다!
```
```java
public class Singleton {
    private static Singleton singleton;

    private Singleton() {
    }
    
    public static Singleton getInstance() {
        if (singleton == null) 
            singleton = new Singleton();
        return singleton;
    }
}
```
```
눈에 띄는 것은 private 생성자와 getInstance입니다.
private으로 생성자를 만들어 외부에서 생성되는 것을 막습니다.
또한 getInstance로 불러오게끔 하여 단일 객체만을 지원합니다.
따라서 static을 사용하면서 안정적인 객체를 생성할 수 있게 됩니다.

필요한 로직이 Class에 있으면서 쓰레기 객체가 생성될 수 없는 방법으로,
저자가 해결하고자 했던 악마도 퇴치가 가능한 것 같네요!
```
