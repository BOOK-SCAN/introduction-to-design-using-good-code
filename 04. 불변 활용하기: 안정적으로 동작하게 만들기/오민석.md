# 📌 Contents

### 📌 다시 쓰기 금지
- 재할당을 막기 위해 불변 변수로 모두 바꿉니다.
- 가변 인스턴스를 사용하지 못하도록 final 키워드를 넣습니다.

<br/>

### 📌 예기치 못한 에러의 발생지, 부수 효과
- 함수가 '매개변수 전달받고 값을 리턴하는 것' 이외에 외부 상태를 변경하는 것입니다.
- 함수의 영향 범위를 한정하고 불변으로 만들어 예기치 못한 동작을 막습니다.

<br/>

### 📌 불변과 가변을 다루는 단계
- 기본적으로 불변을 활용합니다.
- 성능이 중요하거나 스코프가 국소적일 시 가변을 사용합니다.
- 변수가 가변이라면 상태를 변화시키는 메서드, 뮤테이터를 구현합니다.
- 코드 외부와 데이터 교환은 국소화합니다.

<br/>

# ❓ Questions

### ❓ C++은 어떻게 불변 객체를 다뤄야 할까?
```
Java의 경우에는 불변 객체를 다루는 중에 객체가 바뀌어도
가비지 컬렉션의 과정에서 메모리 초과나 누수가 생기지 않습니다.
그렇다면, 가비지 컬렉션이 없는 C++은 어떻게 다뤄야 할까요?

1. 수동으로 delete를 넣어줍니다.
2. 스마트 포인터 등의 자동 메모리 제어를 해줍니다.
```
```cpp
class A {
    private:
        int a;
    public:
        Person(const int a): a(a) {}
        ~Person() {cout << "erase!" << endl;}
}

int main() {
    unique_ptr<A> obj = make_unique<A>(3);
    return 0;    // erase!
}
```
```
위와 같이 스마트 포인터를 사용하면 C++에서도 불변 객체를 다루기 쉽습니다.
따라서 C++에 대한 관심이 많다면 아래의 포인터도 공부해보면 좋을 것 같습니다.
1. unique_ptr
2. shared_ptr
3. weak_ptr
```

<br/>

### ❓ 리포지토리 패턴이란 무엇일까?
![RP](https://github.com/BOOK-SCAN/introduction-to-design-using-good-code/assets/68336833/04c39f1a-af7b-4840-aef6-fd3862a79cb2)
```
리포지토리 패턴은 Domain과 Data Source Layer 간에 중재자 역할을 수행하는 것이라고 합니다.
이는 영속성 장치에서 쿼리의 결과로 받아온 데이터를 도메인 객체로 매핑하는 역할을 합니다.

그렇다면 영속성 장치는 무엇일까요?
이는 데이터를 생성한 프로그램이 종료되어도 사라지지 않는 즉, DB를 말합니다.

정리하면 DB에서 받아온 데이터를 도메인 객체로 변환하여 쉽게 만들어주는 것입니다.
마무리로 아래의 시퀀스 다이어그램을 보면서 다시 짚어보도록 합시다!
```
![RPD](https://github.com/BOOK-SCAN/introduction-to-design-using-good-code/assets/68336833/084b5a58-9350-4914-8746-1e2b9e0c81c5)
