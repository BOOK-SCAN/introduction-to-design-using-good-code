# 📌 CONTENT

## 📌 static 메서드 오용

- static 메서드가 정의되어 있는 OrderManager 클래스
- static ㅔㅁ서드와 데이터 클래스를 함께 사용하는 상황

### static 메서드는 인스턴스 변수를 사용할 수 없음

따라서 어떤 메서드를 static 메서드로 만든 시점에 이미 데이터와 데이터를 조작하는 로직 사이에 괴리가 생긴다. → 응집도 낮아짐

### 인스턴스 변수를 사용하는 구조로 변경하기

응집도: 클래스 내부에서 데이터와 로직의 관계가 얼마나 강한지 나타내는 지표

따라서 ‘인스턴스 변수’와 ‘인스턴스 변수를 사용하는 로직’을 같은 클래스에 만드는 것이 응집도를 높이는 방법이다.

### 인스턴스 메서드인 척하는 static 메서드 주의하기

static 키워드가 붙지 않아도, static 메서드와 같은 문제를 갖고 잇는 인스턴스 메서드를 자주 볼 수 있다.

```cpp
class PaymentManager {
	private int discountRate; //할인율
	
	//생략
	
	int add(int moneyAmount1, int moneyAmount2) {
		return moneyAmount1 + moneyAmount2;
	}
}
```

add 메서드는 인스턴스 메서드지만 인스턴스 변수 discountRate를 사용하지 않는다. OrderManager의 static 메서드였던 add와 차이가 없다.

→ 인스턴스 메서드인 척하는 static 메서드도 응집도를 낮춘다.

→ 이런 거 구분하는 방법: 메서드 앞에 static 키워드를 추가해보기

### 왜 static 메서드를 사용할까?

객체 지향 언어를 사용할 때, C언어 같은 절차 지향 언어의 접근 방법을 사용하려 하기 때문이다.

절차 지향 언어에서는 데이터와 로직이 따로 존재하도록 설계한다. 

이러한 접근 방법을 객체 지향 언어에 적용하여 설계하면, 데이터와 로직을 별도의 클래스에 배치하게 된다. 그래서 클래스의 인스턴스를 생성하지 않고도 사용할 수 있는 static 메서드를 활용하는 것이다.

응집도: 클래스 내부에서 데이터와 로직의 관계가 얼마나 강한지 나타내는 지표

### static 메서드를 사용하면 좋은 상황

응집도의 영향을 받지 않는 경우, static 메서드를 사용해도 좋다.

ex. 로그 출력 전용 메서드, 포맷 변환 전용 메서드, 팩토리 메서드(5.2.1절)

## 초기화 로직 분산

팩토리 메서드

### 생성 로직이 많아지면 팩토리 클래스를 고려해보자

## 범용 처리 클래스(Common/Util)

static 메서드를 빈번하게 볼 수 있는 클래스로, 범용 처리를 위한 클래스가 있다.

일반적으로 `Common`, `Util` 이란 이름이 붙는다.

문제: 응집도가 낮은 구조가 만들어질 수 있다.

### 너무 많은 로직이 한 클래스에 모이는 문제

```cpp
class Common{
	//세금 포함 금액 계산
	static BigDecimal calcAmountIncludingTax(BigDecimal amountExcludingTax, BigDecimal taxRate) {...}
	
	//사용자가 이미 탈퇴했다면 true
	static boolean hasResigned(User user) {...}
	
	//상품 주문하기
	static void createOrder(Product product) {...}
	
	//유효한 전화번호라면 true
	static boolean IsValidPhoneNumber(String phoneNumber) {...}
}
```

4 메서드는 서로 관련없는 로직이다. 모두 Common 클래스 안에 모여있는데 이는 응집도가 낮은 구조이다.

꼭 필요한 경우가 아니면 범용 처리 클래스를 만들지 않는 것이 좋다.

### 횡단 관심사

→ 다양한 상황에서 넓게 활용되는 기능

- 로그 출력
- 오류 확인
- 디버깅
- 예외 처리
- 캐시
- 동기화
- 분산 처리

횡단 관심사에 해당하는 기능이면 범용 코드로 만들어도 된다.

## 결과를 리턴하는데 매개변수 사용하지 않기

```cpp
class ActorManager{
//게임 캐릭터 위치를 이동
	void shift(Location location, int shiftX, int shiftY){
		location.x += shiftX;
		location.y += shiftY;
	}
}
```

해당 코드는 이동 대상 인스턴스를 매개변수 location으로 전달받고, 이를 변경하고 있다. 이렇게 출력으로 사용되는 매개변수를 출력 매개변수라고 부른다.

매개변수는 입력으로 전달하는 것이 일반적이다. 이를 출력으로 사용해 버리면, 매개변수가 입력인지 출력인지 메서드 내부의 로직을 확인해야 하므로 가독성이 좋지 않다.

데이터 조작 대상은 Location, 조작 로직은 ActorManager이다.

데이터와 로직이 각자 다른 클래스에 있는 것이다. → 응집도가 낮은 구조

```cpp
class Location{
	final int x;
	final int y;
	
	Location(final int x, final int y){
		this.x = x; this.y = y
	}
	
	Location shift(final int shiftX, final int shiftY){
		final int nextX = x + shiftX;
		final int nextY = y + shiftY;
		return new Location(nextX, nextY);
	}
}
```

🔺매개변수를 변경하지 않는 구조로 개선

<aside>
👉🏻 C#의 out 키워드
→ C#엔 출력 매개변수임을 명시하는 out키워드와 ref키워드가 있다.

</aside>

```cpp
static void Set(out int value){
	value = 10;
}

int value;
Set(out value);
Console.WriteLine(value); //화면에 10을 출력한다.
```

out을 붙이면 매개변수 value는 참조 전달되며, 함수 안에서는 전달받은 변수를 변경할 수 있다.

## 매개변수가 너무 많은 경우

매개변수가 너무 많은 메서드는 응집도가 낮아지기 쉽다.

### 기본 자료형에 대한 집착을 버려라

데이터는 단순히 존재하기만 할 수 없다. 데이터를 사용해 계산하거나 데이터를 판단해서 제어 흐름을 전환할 때 사용된다.

매개변수를 클래스로 주는 방법을 사용!

### 의미 있는 단위는 모두 클래스로 만들기

## 메서드 체인

```cpp
/**
*갑옷 입기
*@param memberId 장비를 변경하고 싶은 멤버의 ID
*@param newArmor 입을 갑옷
*/
void equipArmor(int memberId, Armor newArmor) {
	if(party.members[memberId].equipments.canChange) {
		party.members[memberId].equipments.armor = newArmor;
	}
}
```

.(점)으로 여러 메서드를 연결해서 리턴 값의 요소에 차례차례 접근하는 방법을 메서드 체인이라고 한다.

이 방법도 응집도를 낮출 수 있어 좋지 않다.

데메테르의 법칙 : 사용하는 객체 내부를 알아서는 안 된다.

### 묻지 말고 명령하기

다른 객체의 내부 상태(변수)를 기반으로 판단하거나 제어하려고 하지 말고, 메서드로 명령해서 객체가 알아서 판단하고 제어하도록 설계하라는 의미

인스턴스 변수를 private로 변경해서, 외부에서 접근할 수 없게 한다.

```cpp
/** 장비하고 있는 방어구 목록*/
class Equipments {
	private boolean canChange;
	private Equipment head;
	private Equipment armor;
	private Equipment arm;
	
	/**
	*갑옷 정비하기
	*
	*@param newArmor 장비할 갑옷
	*/
	void equipArmor(final Equipment newArmor) {
		if (canChange) {
			armor = newArmor;
			}
		}
		
		/**
		*전체 장비 해체하기
		*/
		void deactivateAll() {
			head = Equipment.EMPTY;
			armor = Equipment.EMPTY;
			arm = Equipment.EMPTY;
		}
	} 
```

🔺상세한 로직은 호출하는 쪽이 아니라, 호출되는 쪽에 구현하기
