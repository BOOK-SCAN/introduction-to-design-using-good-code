# 📌 Contents

### 📌 조건 분기가 중첩되어 낮아지는 가독성
- 조기 리턴으로 중첩 제거하기
  + 조기 리턴: 조건을 만족하지 않는 경우 곧바로 리턴하는 방법
  + 중첩이 제거되어 가독성이 좋아짐
  + 조건 로직과 실행 로직을 분리할 수 있음
- 가독성을 낮추는 else 구문도 조기 리턴으로 해결하기
  + 조기 리턴을 해주면 else절도 사용할 필요가 없어짐

### 📌 switch 조건문 중복
- switch 조건문은 많이 사용되지만 악마를 불러들이기 매우 쉬운 제어 구조
- switch 조건문을 여러 번 사용하는 것의 문제점
  + 요구 사항 변경 시 수정 누락(case 구문 추가 누락): 코드 담당자들끼리 혼란 발생 가능
  + 폭발적으로 늘어나는 switch 조건문 중복
- 문제점을 해소하는 방법
  + 조건 분기 모으기: 단일 책임 선택의 원칙(조건식이 같은 조건 분기를 여러 번 작성하지 말고 한 번에 작성)
  + 인터페이스로 중복 해소: 기능 변경을 편리하게 할 수 있는 문법으로, 분기 로직을 작성하지 않고도 분기와 같은 기능 구현 가능
- 인터페이스를 switch 조건문 중복에 응용하기(전략 패턴)
  + 종류별로 다르게 처리해야 하는 기능을 인터페이스의 메서드로 정의하기
  + 종류별로 클래스로 만들기
  + 각각의 클래스에 인터페이스 구현하기
  + switch 조건문이 아니라, Map으로 변경하기
  + 메서드를 구현하지 않으면 오류로 인식하게 만들기
  + 값 객체화 만들기
 

### 📌 조건 분기 중복과 중첩
- 인터페이스는 switch 조건문의 중복을 제거할 수 있을 뿐만 아니라, 다중 중첩된 복잡한 분기를 제거하는 데에도 활용 가능
- 같은 판정 로직을 재사용하는 방법
  + 정책 패턴(조건을 부품처럼 만들고, 부품으로 만든 조건을 조합해서 사용)으로 조건 집약하기


### 📌 자료형 확인에 조건 분기 사용하지 않기
- 리스코프 치환 원칙: 클래스의 기반 자료형과 하위 자료형 사이에 성립하는 규칙으로, 기반 자료형을 하위 자료형으로 변경해도 코드는 문제없이 동작해야 한다는 의미

### 📌 인터페이스 사용 능력이 중급으로 올라가는 첫 걸음
- 조건 분기를 써야 하는 상황에서는 일단 인터페이스 설계를 떠올리자!


### 📌 플래그 매개변수
- 플래그 매개변수: 메서드의 기능을 전환하는 boolean 자료형의 매개변수
- 플래그 매개변수를 받는 메서드는 어떤 일을 하는지 예측하기 굉장히 힘듦
- 메서드 분리하기
  + 플래그 매개변수를 받는 메서드는 내부적으로 여러 기능을 수행 -> 플래그 매개변수를 받는 메서드는 기능별로 분리하는 것이 좋음
- 전환은 전략 패턴으로 구현하기
  + 전환해야할 때는 플래그 매개변수가 아니라 전략 패턴을 사용하라.

# ❓ Questions

### ❓  책에서 왜 enum을 사용할까?
- 과거에 상수를 정의한 방법
  1) final 상수: 접근제어자들 때문에 가독성이 좋지 못함
  2) 인터페이스 상수: 잘못된 상수가 할당되었음에도 결국은 정수값이기 때문에 컴파일 에러없이 실행될 수 있음
  3) 자체 클래스 상수: 가독성이 다시 안좋아졌고, 무엇보다 이러한 방식은 if문에서는 문제는 없지만 switch문에서 사용할수 없다는 큰 단점이 있음

- 이러한 문제들때문에 자바에서는 아예 상수만을 다루는 enum 타입 클래스를 만들어 배포
- C언어의 enum은 그냥 정수이며, C++의 enum은 타입이지만, JAVA의 enum은 인터페이스와 같이 독립된 특수한 클래스로 구분한다. 즉, 일종의 객체이기 때문에 힙(heap) 메모리에 저장되며 각 enum 상수들은 별개의 메모리 주소값을 가짐으로써 완벽히 독립된 상수를 구성할 수 있다.

### ❓  C++의 인터페이스?
- C++은 인터페이스 기능을 별도로 제공하지 않기 때문에 추상 클래스를 순수 가상 함수만으로 선언하여 Interface처럼 사용한다.
- 인터페이스 클래스에는 가상 소멸자와 순수 가상함수만 포함된다.
- 인터페이스 클래스는 순수 가상 함수 선언을 기본 클래스로 지정하는 클래스이다.

```
class IClass
{
public:
    virtual ~IClass(); // 꼭 선언하지 않아도 됨
    virtual void move_x(int x) = 0;
    virtual void move_y(int y) = 0;
    virtual void draw() = 0;
};
```
