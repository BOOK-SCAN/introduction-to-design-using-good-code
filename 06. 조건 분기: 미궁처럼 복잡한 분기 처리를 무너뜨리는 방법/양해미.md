# 📌 CONTENTS

## 📌조건 분기가 중첩되어 낮아지는 가독성

if 조건물을 중첩하면 어떤 문제가 생길까?

→ 코드의 가독성이 크게 떨어지는 문제가 있다.

### 조기 리턴으로 중첩 제거하기

조건을 만족하지 않는 경우 곧바로 리턴하는 방법이다.

조기 리턴은 가독성을 좋게 만들고, 조건 로직과 실행 로직을 분리할 수 있다.

### 가독성을 낮추는 else 구문도 조기 리턴으로 해결하기

else 구문도 가독성을 나쁘게 만드는 원인 중 하나

else 구문도 중첩과 마찬가지로 조기 리턴 사용(조기 리턴 사용하면 else를 쓸 필요 없음)

## switch 조건문 중복

### 조건 분기 모으기

switch 조건문 중복을 해소하려면, 단일 책임 선택의 원칙을 생각해 봐야 한다.

> 소프트웨어 시스템이 선택지를 제공해야 한다면,  그 시스템 내부의 어떤 한 모듈 만으로 모든 선택지를 파악할 수 있어야 한다.
> 

```cpp
class Magic{
	final String name;
	final int costMagicPoint;
	final int attackPower;
	final int costTechnicalPoint;
	
	Magic(final MagicType magicType, final Member member) {
		switch (magicType) {
			case fire:
				name = "파이어";
				constMagicPoint = 2;
				attackPower = 20+ (int)(member.level * 0.5);
				costTechnicalPoint = 0;
				break;
			case lightning:
				name = "라이트닝";
				constMagicPoint = 5 + (int)(member.level * 0.2);
				attackPower = 50 + (int)(member.agility * 1.5);
				costTechnicalPoint = 5;
				break;
			case hellFire:
				name = "헬파이어";
				constMagicPoint = 16
				attackPower = 200 + (int)(member.magicAttack*0.5 + member.vitality * 2);
				costTechnicalPoint = 20 + (int)(member.lever * 0.4);
				break;
			default:
				throw new IllegalArgumentException();
			}
		}
	}
```

한 번에 묶으라.

### 인터페이스로 switch 조건문 중복 해소하기

클래스가 거대해지면 데이터와 로직의 관계를 파악하기 힘들어진다. 유지 보수와 변경이 어려운 코드가 된다는 것이다.

→ 클래스가 거대해지면 관심사에 따라 작은 클래스로 분할하는 것이 좋다.

→ 인터페이스 사용

인터페이스 : 객체 지향 프로그래밍 언어 특유의 문법으로, 기능 변경을 편리하게 할 수 있는 개념

인터페이스를 사용하면, 분기 로직을 작성하지 않고 분기와 같은 기능을 구현할 수 있다.

```cpp
//사각형
class Rectangle implements Shape{
	private final double width;
	private final double height;
	//생략
	public double area() {
		return width * height;
	}
}

//원
class Circle implements Shape{
	private final double radius;
	//생략
	public double area() {
		return radius * radius * Math.PI;
	}
}
```

이렇게 인터페이스를 구현하면 Rectangle과 Circle을 Shape라는 자료형으로 다룰 수 있다.

### 인터페이스를 switch 조건문 중복에 응용하기 (전략 패턴)

인터페이스의 이름을 결정하는 법: 어떤 부류에 속하는가?

종류별로 클래스 만들기

| 마법 | 클래스 |
| --- | --- |
| 파이어 | Fire |
| 라이트닝 | Lightning |
| 헬파이어 | HellFire |

각각의 클래스에 인터페이스 구현하기

```cpp
//마법 '파이어'
class Fire implements Magic {
	private final Member member;
	
	Fire(final Member member) {
		this.member = member;
	}
	
	public String name() {
		return "파이어";
	}
	
	public int costMagicPoint() {
		return 2;
	}
	
	public int attackPower() {
		return 20 + (int)(member.level * 0.5);
	}
	
	public int costTechnicalPoint() {
		return 0;
	}
}
```

각 마법 클래스에서 Magic 인터페이스를 구현한다.

다른 마법은 생략

switch 조건문이 아니라, Map으로 변경하기

```cpp
final Map<MagicType, Magic> magics = new HashMap<>();
//생략
final Fire fire = new Fire(member);
final Lightning lightning = new Lightning(member);
final HellFire hellFire = new HellFire(member);

magics.put(MagicType.fire, fire);
magics.put(MagicType.lightning, lightning);
magics.put(MagicType.hellFire, hellFire);
```

메서드를 구현하지 않으면 오류로 인식하게 만들기

→ 인터페이스에 메서드를 추가했는데 구현하지 않았다면 컴파일 실패

값 객체화하기

메서드 리턴 값의 자료형은 String 또는 int 이기 때문에 매직포인트, 공격력, 테크니컬 포인트를 값 객체로 만든다.

```cpp
interface Magic {
	String name();
	MagicPoint costMagicPoint();
	AttackPower attackPower();
	TechnicalPoint costTechnicalPoint();
}
```

```cpp
//마법 '파이어'
class Fire implements Magic {
	private final Member member;
	
	Fire(final Member member) {
		this.member = member;
	}
	
	public String name() {
		return "파이어";
	}
	
	public int costMagicPoint() {
		return new MagicPoint(2);
	}
	
	public int attackPower() {
		final int value = 20 + (int)(member.level * 0.5);
		return new AttackPower(value)
	}
	
	public int costTechnicalPoint() {
		return new TechnicalPoint(0);
	}
}
```

## 조건 분기 중복과 중첩

### 정책 패턴으로 조건 집약하기

→ 조건을 부품처럼 만들고, 부품으로 만든 조건을 조합해서 사용하는 패턴이다.

```cpp
class ExcellentCustomerPolicy {
	private final Set<ExcellentCustomerRule> rules;
	
	ExcellentCustomerPolicy() {
		rules = new HashSet();
	}
	
	/**규칙 추가
	*@param rule 규칙
	*/
	void add(final ExcellentCustomerRule rule) {
		rules.add(rule);
	}
	
	/**
	@param history 구매 이력
	@return 규칙을 모두 만족하는 경우 true
	*/
	boolean complyWithAll(final PurchaseHistory history){
		for (ExcellentCustomerRule each : rules) {
			if(!each.ok(history)) return false;
		{
		return true;
	}
}
```

```cpp
class GoldCustomerPolicy{
	private final ExcellentCustomerPolicy poicy;
	
	GoldCustomerPolicy() {
		policy = new ExcellentCustomerPolicy();
		policy.add(new GoldCustomerPurchaseAmountRule());
		policy.add(new PurchaseFrequencyRule());
		policy.add(new ReturnRateRule());
	}
	
	/**
	@param history 구매이력
	@return 규칙을 모두 만족하는 경우 true
	*/
	
	boolean comlyWithAll(final PurchaseHistory history) {
		return policy.complyWithAll(history);
	}
}
```

## 자료형 확인에 조건 분기 사용하지 않기

인터페이스를 사용해도 조건 분기가 줄어들지 않는 경우

```cpp
interface HotelRates {
	Money fee();
}
```

🔺숙박 요금을 나타내는 인터페이스

```cpp
Money busySeasonFee;
if(hotelRates instanceof RegularRates) {
	busySeasonFee = hotelRates.fee().add(new Money(30000));
}
else if (hotelFates instanceof PremiumRates) {
	busySeasonFee = hotelRates.fee().add(new Money(50000));
```

🔺자료형 판정을 기반으로 성수기 요금 분기

이러면 자료형 판정을 위한 조건 분기 코드가 점점 많아져서 유지보수하기 어려운 코드가 되어 버린다.

```cpp
interface HotelRates{
	Money fee();
	Money busySeasonFee(); //성수기 요금
}
```

🔺인터페이스에 성수기 요금을 리턴하는 메서드 정의

```cpp
class RegularRates implements HotelRates {
	public Money fee() {
		return new Money(70000);
	}
	
	public Money busySeasonFee() {
		return fee().add(new Money(30000));
	}
}
```

```cpp
class PremiumRates implements HotelRates {
	public Money fee() {
		return new Money(120000);
	}
	
	public Money busySeasonFee() {
		return fee().add(new Money(50000));
	}
}
```

이렇게 인터페이스 구현 클래스에서 busySeasonFee를 구현하면 호출 시 instanceof로 자료형을 판정하지 않아도 된다.

## 인터페이스 사용 능력이 중급으로

인터페이스를 잘 사용하는지가 곧 설계 능력의 전환점이다.

|  | 초보자 | 중급자 이상 |
| --- | --- | --- |
| 분기 | if 조건문과
switch 조건문만 사용 | 인터페이스 설계 사용 |
| 분기마다의 처리 | 로직을 그냥 작성 | 클래스 사용 |

조건 분기를 써야 하는 상황엔 인터페이스 설계!

## 플래그 매개변수

→ 메서드 기능을 전환하는 boolean 자료형의 매개 변수

플래그 매개변수를 받는 메서드는 어떤 일을 하는지 예측하기 굉장히 힘들다.

→ 가독성 낮아짐, 개발 생산성 저하

### 메서드 분리하기

플래그 매개변수를 받는 메서드는 기능 별로 분리하는 것이 좋다.

메서드는 하나의 기능만 하도록 설계하기

### 전환은 전략 패턴으로 구현하기

# ❓Questions

## ❓java) implements vs. extends (상속)

### extends

- 사실 extends가 상속의 대표적인 형태
- 부모의 메소드를 그대로 사용할 수 있으며 오버라이딩 할 필요없이 부모에 구현 되어 있는 것을 직접 사용 가능
- extends는 일반 클래스와 abstract 클래스 상속에 사용된다.
- extends는 클래스 한 개만 상속 가능.

### implements

- implements의 가장 큰 특징은 이렇게 부모의 메소드를 반드시 오버라이딩(재정의)해야 한다.
- interface 상속에 사용된다.
- class가 interface를 사용할 땐 implements를 써야한다.
- 여러 개 사용 가능

즉, extends는 클래스를 확장하는 거고 implements는 인터페이스를 구현하는 것이다.

## ❓전략 패턴이란?

> 전략 패턴은 **실행(런타임) 중에 알고리즘 전략을 선택하여 객체 동작을 실시간으로 바뀌도록 할 수 있게 하는 행위 디자인 패턴**이다.
> 
- 전략 알고리즘 객체들 : 알고리즘, 행위, 동작을 객체로 정의한 구현체
- 전략 인터페이스: 모든 전략 구현제에 대한 공용 인터페이스
- 컨텍스트: 알고리즘을 실행해야 할 때마다 해당 알고리즘과 연결된 전략 객체의 메소드를 호출.
- 클라이언트: 특정 전략 객체를 컨텍스트에 전달함으로써 전략을 등록하거나 변경하여 전략 알고리즘을 실행한 결과를 누린다.

### 장점

- 알고리즘 교체 용이성: 실행 중에 다른 알고리즘으로 쉽게 전환할 수 있다.
- 코드 재사용성 : 다른 무제에 대해서도 해당 전략을 재사용할 수 있다.
- 유연성: 동적으로 알고리즘은 변경할 수 있다.
- 결합도 감소: 응집도랑 같은 개념인가 보다.

### 단점

- 객체 수 증가: 다양한 전략을 사용하고자 하는 경우, 각각의 전략에 대한 객체를 생성해야 한다.
- 코드 복잡성: 전략 패턴을 코드에 도입하면 구조가 복잡해질 수 있다.
- 초기 학습 곡선: 개발자들은 전략 패턴을 이해하고 효율적으로 사용하는 데 시간이 필요할 수 있다.

출처 -  [https://velog.io/@hkoo9329/자바-extends-implements-차이](https://velog.io/@hkoo9329/%EC%9E%90%EB%B0%94-extends-implements-%EC%B0%A8%EC%9D%B4)

[https://inpa.tistory.com/entry/GOF-💠-전략Strategy-패턴-제대로-배워보자](https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EC%A0%84%EB%9E%B5Strategy-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90)
