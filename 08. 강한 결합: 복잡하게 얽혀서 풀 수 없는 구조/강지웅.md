# 📌 Contents

### 📌 결합도와 책무
- 결합도: 모듈 사이의 의존도를 나타내는 지표, 결합도가 높을수록 강한 결합이라고 부른다.
- 소프트웨어의 책임(책무): 자신의 관심사와 관련해서, 정상적으로 동작하도록 제어하는 것
- 단일 책임 원칙: 클래스가 담당하는 책임은 하나로 제한해야 한다.
- 단일 책임 원칙 위반으로 만들어진 악마 퇴치
  + 책임이 하나가 되게 클래스 설계하기: 느슨한 결합
- DRY 원칙: 각각의 개념 단위 내에서 반복을 하지 말라는 의미
  + 그러나 같은 로직, 비슷한 로직이라도 개념이 다르면 중복을 허용해야 한다. 개념적으로 다른 것까지도 무리하게 중복을 제거하려 하면, 강한 결합 상태가 된다. 즉, 단일 책임 원칙이 깨진다.

### 📌  강한 결합 사례와 대처 방법
- 상속 관계: 상속 관계에서 서브 클래스는 슈퍼 클래스에 굉장히 크게 의존한다. 따라서 서브 클래스는 슈퍼 클래스의 구조를 하나하나 신경 써야 한다. -> 상속보다 컴포지션 사용
- 책임이 다른 메서드가 한 클래스 안에 정의되어 있으면, 여러 문제가 발생할 수 있다.
  + 클래스를 잘 분리하려면 각각의 인스턴스 변수와 메서드가 무엇이 있는지 잘 파악해야 한다. -> 영향 스케치
- 특별한 이유없이 public 사용하지 않기
  + 이유 없이 public으로 만들면, 관계를 맺지 않았으면 하는 클래스끼리도 결합되어, 영향 범위가 확대된다. -> 결과적으로 유지 보수가 어려운 강한 결합구조가 된다.
  + 접근 수직자로 가시성을 적절하게 제어해야 한다.
- private 메서드가 너무 많다는 것은 책임이 너무 많다는 것: 책임이 다른 메서드는 다른 클래스로 분리하는 것이 좋다.
- 응집도를 높이기 위해 관련이 깊다고 생각되는 로직을 한 곳에 모으려하다 강한 결합 구조를 만들 수 있다. -> 각각의 개념을 각각의 클래스에 잘 분할해서 값 객체로 설계하는 것이 좋다.
- 스마트 UI: 화면 표시와 직접적인 관련이 없는 책무가 구현되어 있는 클래스
  + 화면 표시에 관한 책무와 그렇지 않은 책무가 강하게 결합되어 있기 떄문에 변경하기 힘들다.
  + 서로 다른 클래스로 분할하는 것이 좋다.
- 거대 데이터 클래스: 부주의한 변경으로 인해 버그가 발생할 가능성이 높아진다.
- 트랜잭션 스크립트 패턴: 메서드 내부에 일련의 처리가 하나하나 길게 작성되어 있는 구조
  + 남용하면 응집도는 낮아지고 결합은 강해질 수 있다.
- 갓 클래스: 하나의 클래스 내부에 수천에서 수만 줄의 로직을 담고 있으며, 수많은 책임을 담당하는 로직이 난잡하게 섞여 있는 클래스
- 위의 강한 결합 클래스에 대처하는 방법
  + 객체 지향 설계와 단일 책임 원칙에 따라 제대로 설계하는 것
  + 거대한 강한 결합 클래스: 책임별로 클래스 분할
  + 조기 리턴, 전략 패턴, 일급 컬렉션, 목적 중심 이름 설계 등의 방법이 있다.

# ❓ Questions

### ❓  반복? 중복?

```
"일반 할인과 여름 할인은 서로 다른 개념입니다.
DRY는 각각의 개념 단위 내에서 반복을 하지 말라는 의미입니다.
같은 로직, 비슷한 로직이라도 개념이 다르면 중복을 허용해야 합니다.
개념적으로 다른 것까지도 무리하게 중복을 제거하려 하면, 강한 결합 상태가 됩니다. 단일 책임 원칙이 깨지는 것입니다."
```
-> 이게 무슨 소리지
