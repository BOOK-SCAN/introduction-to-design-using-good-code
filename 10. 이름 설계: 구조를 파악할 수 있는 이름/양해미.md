대충 이름을 붙였을 때 어떤 악마가 태어나는지, 이 악마를 퇴치하려면 이름을 어떻게 붙여야 하는지 등 ‘이름 설계 방법’에 대해 알아봄.

## 목적 중심 이름 설계

## 악마를 불러들이는 이름

상품을 그대로 ‘상품 클래스’라고 이름 붙이는 것이다.

‘상품 클래스’라고 붙이면, 여러 유스케이스와 관계를 맺게 된다. 그러면 강한 결합 구조가 되어 버린다.

이렇게 거대해진 상품 클래스에 사양 변경이 발생하면 상품 클래스와 관련된 클래스를 모두 확인해 봐야 한다. → 개발 생산성 저하될 것이다.

### 관심사 분리

강한 결합을 해소하고, 결합이 느슨하고 응집도가 높은 구조로 만들려면 **관심사 분리**를 할 수 있어야 한다. 

### 관심사에 맞는 이름 붙이기

주문 목적의 상품은 → ‘주문 상품’

에약 목적의 상품 → ‘예약 상품’

발송 → ‘발송 상품’

이런 식으로 관심사에 맞는 이름을 붙일 수 있다.

### 포괄적이고 의미가 불분명한 이름

의미가 너무 포괄적인 이름은 내부에 온갖 로직을 구현하게 만든다.

혹자는 이름이 너무 포괄적이라서 목적이 불분명한 클래스를 **목적 불명 객체**라고 부른다.

이런 상황에 빠지지 않으려면 , 관심사 분리를 고려한 이름을 설계해야 한다. 비즈니스 목적에 따라 이름을 붙여 보면 된다.

### 이름 설계하기 - 목적 중심 이름 설계

**이름 설계 -** 클래스와 메서드에 이름을 붙이는 것

이름은 가독성을 높이는 역할을 함.

목적 중심 이름 설계는 결합이 느슨하고 응집도가 높은 구조를 만드는 데 굉장히 중요한 역할을 한다.

- 최대한 구체적이고, 의미 범위가 좁고, 특화된 이름 선택하기
    - 목적 중심 이름 설계에서 가장 중요 포인트
    - 발생하는 효과
        - 이름과 관계없는 로직을 배제하기 쉬워짐
        - 클래스가 작아짐
        - 관계된 클래스 개수가 적으므로, 결합도가 낮아짐
        - 관계된 클래스 개수가 적으므로, 사양 변경 시 생각해야 하는 영향 범위가 좁음
        - 목적에 특화된 이름을 갖고 있으므로, 어떤 부분을 변경해야 할 때 쉽게 찾을 수 있음
        - 개발 생산성 향상
- 존재가 아니라 목적을 기반으로 하는 이름을 생각하기
    - 주소 → 발송지, 배송지
    - 금액 → 청구 금액, 소비세액, 연체 보증료, 캠페인 할인 금액 등
- 어떤 관심사가 있는지 분석하기
    - 쇼핑몰 - 판매 제품, 주문, 발송, 캠페인 등
    - 게임 - 무기, 몬스터, 아이템, 기간 이벤트 등
    - sns - 메시지, 팔로워, 타임라인 등
- 소리 내어 이야기해 보기
    - 고무 오리 디버깅 - 프로그래밍에서 어떤 문제가 발생했을 때, 문제를 누군가에게 설명하다 보면 스스로 원인을 깨닫고 해결할 수 있다는 방법
    - 유비쿼터스 언어 - 이야기하면서 분석하는 활동 (in 도메인 주도 설계 (책임)), 팀 전체에서 의도를 공유하기 위한 언어
- 이용 약관 읽어보기
- 다른 이름으로 대체할 수 없는지 검토하기
- 결합이 느슨하고 응집도가 높은 구조인지 검토하기

## 이름 설계 시 주의 사항

- 이름에 관심 갖기
    - 팀 개발에서는 이름이 중요하다. 이름과 로직이 대응된다는 전제, 이름이 프로그램 구조를 크게 좌우한다는 사실을 팀원들과 이야기해야 한다.
- 사양 변경 시 ‘의미 범위 변경’ 경계하기
    - 여러 의미가 섞이면, 이름이 의미하는 바를 다시 검토해 봐야 한다.
- 대화에는 등장하지만 코드에 등장하지 않는 이름 주의하기
    - ‘문제가 있는 회원’을 이름을 ‘문제가 있는 회원’으로 하지 않고 암시적으로 인스턴스 변수 ‘대여 연체 횟수’와 ‘도서 파손 횟수’가 일정 횟수 이상인 User 클래스라고 정했을 때
- 수식어를 붙여서 구별해야 하는 경우는 클래스로 만들어 보기
    - 캐릭터의 원래 최대 히트포인트: originalMaxHitPoint
    - 장비 착용으로 높아진 최대 히트포인트 : correctedMaxHitPoint

### 의미를 알 수 없는 이름 (tmp 등)

- 기술 중심 명명 - 컴퓨터과 관련된 용어에서 유래되는 기술을 기반으로 이름 짓는 방법
    - int, memory, flag 등
- 놀람 최소화 원칙 - 사용자가 예상하지 못한 놀라움을 최소화하도록 설계해야 한다는 접근 방법
    - 처음에는 로직과 의도가 일체하게끔 구현했다고 해도, 사양을 변경하면서 별 생각 없이 기존 메서드에 로직을 추가하는 경우가 있다. 이렇게 되면 놀람 최소화 원칙을 위반하게 된다.

### 구조에 악영향을 미치는 이름

- 데이터 클래스처럼 보이는 이름
    - ~Info, ~Data 같은 이름의 클래스는 읽는 사람에게 데이터만 갖는 클래스니까, 로직을 구현하면 안 되는 구나라는 생각을 하게 할 수 있다.
    - 응집도가 낮은 구조가 되기 쉽다.
    - 이 경우엔 ProductInfo → Product 로 개선
    - DTO(Data Transfer Object)
        - 예외적으로 데이터 클래스를 사용하는 경우가 있음
        - 명령 쿼리 역할 분리(CQRS) - 변경 책무와 참조 책무를 모듈로 분리하는 아키텍처 패턴
        - CQRS에서 참조 책무란 데이터 베이스에서 값을 추춘하는 처리로서, 오직 화면 출력만 하면 된다.
        - 값 변경이 필요 없으므로, 인스턴스 변수는 final로 선언하고 생성자에서는 값만 지정된다.
        - 참조 용도로만 사용되어야 하므로, 값을 변경하는 용도로 사용하면 안 된다.

### 클래스를 거대하게 만드는 이름

대표적으로 Manager가 있다. 

MemberManager에 멤버에 관련된 메서드를 추가하니 단일 책임 원칙의 관점에서 이 클래스의 메서드가 가진 책무를 살펴 

# ❓Questions

## ❓DTO 사용하는 이유?

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c90e26ec-23b0-4380-8daf-9f11e4550e28/fa9e1c73-a348-4084-b089-015c8c488055/image.png)

DTO를 사용하면 코드량을 줄이고 읽기 쉬워진다. 엔티티를 사용하면 **DTO**를 사용했을 때보다 보안에 취약해질 수 있죠. **DTO**를 사용함으로서 **엔티티** 내부 구현을 **캡슐화**할 수 있다.

 **DTO**대신 **엔티티**를 사용하면 클라이언트 요구사항에 **엔티티**가 영향을 받을 수 있다.

## ❓엔티티가 뭐죠?

Entity 클래스는 실제 DB 테이블과 매핑되는 핵심 클래스로, 데이터베이스의 테이블에 존재하는 컬럼들을 필드로 가지는 객체다.

(DB의 테이블과 1:1로 매핑되며, 테이블이 가지지 않는 컬럼을 필드로 가져서는 안 된다.)

Entity는 데이터베이스 영속성(persistent)의 목적으로 사용되는 객체이며, 때문에 요청(Request)이나 응답(Response) 값을 전달하는 클래스로 사용하는 것은 좋지 않다.

엔티티 예시

- 고객, 사원 정보, 부서, 제품
- 주문서, 성적표, 입고전표, 금전출납부
