# **📌 Contents**

### **📌 주석을 잘 쓰는 방법**

- 로직을 변경하면서 주석을 함께 변경해야 합니다.
- 주석이 로직을 그대로 설명하지 않도록 합니다.
- 메서드 이름의 가독성을 높여 주석의 추가 설명을 방지합니다.
- 유지 보수를 위해 로직의 의도를 담아 주석을 작성합니다.
<br/>

# **❓ Questions**

### **❓ 주석은 내부적으로 어떻게 구현되어 있을까?**

```
C++에서는 주석을 내부적으로 어떤 방식으로 처리할까요?
사실 주석은 실행에 영향을 끼치지 않으므로 지워버려도 상관없지 않을까요?

gcc 내부에서는 컴파일 시에 주석을 지우는 방식을 사용합니다.
그리고 주석 테이블을 만들어 해당 주석들을 저장하기도 합니다.
그렇다면 해당 주석들을 왜 저장하는 걸까요?
```

```cpp
/* Append a comment to the end of the comment table. */
static void 
store_comment (cpp_reader *pfile, cpp_token *token) 
{
  int len;

  if (pfile->comments.allocated == 0)
    {
      pfile->comments.allocated = 256; 
      pfile->comments.entries = (cpp_comment *) xmalloc
	(pfile->comments.allocated * sizeof (cpp_comment));
    }

  if (pfile->comments.count == pfile->comments.allocated)
    {
      pfile->comments.allocated *= 2;
      pfile->comments.entries = (cpp_comment *) xrealloc
	(pfile->comments.entries,
	 pfile->comments.allocated * sizeof (cpp_comment));
    }

  len = token->val.str.len;

  /* Copy comment. Note, token may not be NULL terminated. */
  pfile->comments.entries[pfile->comments.count].comment = 
    (char *) xmalloc (sizeof (char) * (len + 1));
  memcpy (pfile->comments.entries[pfile->comments.count].comment,
	  token->val.str.text, len);
  pfile->comments.entries[pfile->comments.count].comment[len] = '\0';

  /* Set source location. */
  pfile->comments.entries[pfile->comments.count].sloc = token->src_loc;

  /* Increment the count of entries in the comment table. */
  pfile->comments.count++;
}
```

```
주석 테이블을 사용하여 주석을 저장해두면 다음과 같은 이점이 있다고 합니다.

1. 소스 코드 분석 및 도구 지원
2. 디버깅 과정에서 원본 소스 코드의 주석 확인
3. 컴파일러 경고 및 오류 메시지 개선
4. #pragma 등의 특수한 주석 처리
5. 소스 코드 네비게이션
```
