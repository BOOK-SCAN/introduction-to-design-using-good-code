# **📌 Contents**

### **📌 메서드가 지켜야 할 것들**

- 반드시 현재 클래스의 인스턴스 변수를 사용합니다.
- 불변을 활용해서 예상할 수 있는 메서드를 만듭니다.
- getter와 setter 대신 로직을 해당 클래스에 담습니다.
- 상태 변경과 추출을 동시에 하지 않도록 합니다.

### **📌 메서드 매개변수 원칙**

- 불변 매개변수로 만듭니다.
- 플래그 매개변수를 사용하지 않습니다.
- null을 전달하지 않습니다.
- 출력 매개변수를 사용하지 않습니다.
- 매개변수를 최대한 적게 사용합니다.

### **📌 메서드 리턴 원칙**

- ‘자료형’을 사용해서 리턴 값의 의도를 나타냅니다.
- null을 리턴하지 않습니다.
- 오류는 리턴 값으로 리턴하지 말고 예외 발생시킵니다.
<br/>

# **❓ Questions**

### **❓ 함수는 메모리에서 어떻게 관리될까?**

```
함수는 내부적으로 어떤 방식으로 처리될까요?
함수도 결국에 메모리상에 위치하여 접근할 수 있는 대상일 텐데,
그렇다면 어떤 방식으로 메모리에 위치해 있을까요?

C++과 Python의 예시를 보면서 하나씩 알아보도록 합시다!
```

```cpp
struct vtbl_init_data
{
  tree binfo;
  tree derived;
  tree rtti_binfo;
  vec<constructor_elt, va_gc> *inits;
  tree vbase;
  vec<tree, va_gc> *fns;
  tree index;
  int primary_vtbl_p;
  int ctor_vtbl_p;
  bool generate_vcall_entries;
};
```

```python
from collections.abc import Callable

print(dir(Callable))
# ['__abstractmethods__', '__call__', ...]
```

```
C++의 경우에는 메서드를 메모리에 바인딩하여 가지고 있습니다.
이를 가상 함수 테이블이라고 하고 위의 코드는 해당 테이블의 요소입니다.
하지만 현재에는 function이나 람다 함수 등을 지원하며 Python과 같은 방식도 사용합니다.

Python의 경우에는 메서드를 객체로 가지고 있습니다.
__call__ 메서드를 구현한 Callable 객체로 관리합니다.
정리해 보면 C++은 메모리 바인딩을 Python은 객체로 관리합니다.
```
<br/>

### **❓ 상태 변경과 추출을 동시에 하는 메서드는 왜 문제일까?**

```
상태 변경과 추출을 동시에 할 때 무슨 문제가 생길까요?
그리고 해당 문제를 해결하기 위해선 어떤 방식을 사용할 수 있을까요?
한번 알아보도록 합시다!
```

```cpp
int count = 0;

int countPlusAndReturn() {
		count++;
		return count;
}
```

```
위의 방식은 전역 변수인 count를 변경하며 추출합니다.
그렇다면 동시의 두 개의 쓰레드가 위의 메서드를 사용하면 어떤 결과가 나올까요?

당연하게도 두 쓰레드가 각각 진행하여 한 명은 1을 한 명은 2를 반환받아야합니다.
하지만 둘 다 count를 0으로 인식해 1을 받을 수 있습니다.
이러한 문제를 "동시성"이라고 합니다. 그렇다면 이를 어떻게 해결할 수 있을까요?
```

```cpp
#include <iostream>
#include <thread>
#include <mutex>

int count = 0;
std::mutex countMutex;

int countPlusAndReturn() {
    std::lock_guard<std::mutex> lock(countMutex);
    count++;
    return count;
}
```

```
위의 방식처럼 mutex를 활용한 방식이 있습니다.
이러한 잠금을 통해 쓰레드 간의 동기화를 보장하면 원하는 결과가 나옵니다.
```
