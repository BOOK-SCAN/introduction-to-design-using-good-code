# 이책은 어떤 설계를 주제로 집필한 것?

- 기능 적합성
- 성능 효율성
- 호환성
- 사용성
- 신뢰성
- 보안
- 유지 보수성
- 이식성

<aside>
💡

소프트웨어에서 설계란,
어떤 소프트웨어의 품질 특성을 향상시키기 위한 구조를 만드는 것

</aside>

이 책은 소프트웨어 개발에서 나타날 수 있는 악마를 퇴치하는 설계 방법을 설명해왔다.

- 디버깅이나 사양 변경을 할 때, 어떤 로직에 영향을 미치고 있는지 영향 범위를 파악하기 어렵게 한다.
- 사양 변경 시 수정 누락을 일으켜서 버그를 발생시키는 등, 정확히 동작하게 만들 때까지 시간을 낭비하게 만든다
    - 관련된 특성: 유지 보수성
    - 수정성(변경 용이성)
        - (버그를 발생시키지 않고도) 얼마나 쉽고 정확하게 코드를 변경할 수 있는지 나타내는 지표

## 설계하지 않으면 개발 생산성이 저하된다

악마를 불러들이는 코드 = 변경 용이성이 낮은 코드

변경하기 어렵고 버그가 생기기 쉬운 코드 = 레거시 코드

레거시 코드가 축적되어 있는 상태 = 기술 부채

# 요인

1. 버그가 발생하기 쉬운 구조
- 응집도가 낮은 구조로 인해 사양 변경 시 수정 누락이 발생하기 쉬워지고, 결국 버그가 발생함
- 코드를 이해하기 어려우므로 구현할 때 실수를 저지르기 쉬워지고, 결국 버그가 발생
- 잘못된 값이 들어오기 쉬워지고, 결국 버그가 발생함

1. 가독성이 낮은 구조
- 로직의 가독성이 낮아, 읽고 이해하는 데 시간이 오래 걸림
- 관련된 로직이 이곳저곳에 흩어져 있어, 사양을 변경할 때 관련된 로직을 찾아서 돌아다니는 데 시간이 오래 걸림
- 잘못된 값이 들어와서 버그가 발생했을 때, 잘못된 값의 출처를 추적하기 어려워짐.

## 소프트웨어와 엔지니어의 성장 가능성

<aside>
💡

소프트웨어의 성장 가능성을 높이는 것이 이 책의 핵심 주제

</aside>

엔지니어에게 자산은 기술력

하지만 레거시 코드는 발전을 막는다.

## 문제 해결하기

인지하기 쉬운 문제와 인지하기 어려운 문제

여기에서 ‘보임/보이지 않음’은 시스템의 내부 구조가 보이는가를 나타낸다.

보임: 내부 구조에 대한 이해 없이도 인식 할 수 있다.

- 보이는 쪽
    - 플러스 가치: 신기능
    - 마이너스 가치: 버그
- 보이지 않는 쪽
    - 플러스 가치: 아키텍처
    - 마이너스 가치: 기술 부채

소스코드를 독해하는 스킬과 기술 부채를 인식하는 스킬은 전혀 다르다.

문제는 항상 이상과 현실의 차이 때문에 발생하니 이상이 무엇인지 알고 있따면, 현실과 비교하며 차근차근 문제를 해결할 수 있다.

변경 용이성을 비교할 수 없는 딜레마

- 기술 부채를 줄이는 변경 용이성 설계의 효과를 측정하는 법
    - 성능 기준 비교
        - ‘기존의 코드’와 ‘성능이 향상되도록 변경한 코드’를 준비하고, 실행 속도를 측정하면 곧바로 비교 가능
    - 변경 용이성 기준 비교
        - 개발 생산성으로 추측할 수 있지만, 성능과 달리 곧바로 비교 불가
        - 시간이 경과해야 알 수 있기 때문

- 변경 용이성 설계 효과가 어느 정도인지 어떻게 산출 할 수 있을까?
    - 대조 실험
    - (비용도 많이들고 시간도 많이 들어서 현실적 불가능)

## 코드의 좋고 나쁨을 판단하는 지표

- 실행되는 코드의 줄 수
    - 줄 수가 많으면 많을 수록, 너무 많은 일을 하고 있을 가능성이 높다.
    - 조건 분기로 인해 내부 로직이 복잡해지면 코드를 읽고 이해하기 어려워짐
    - 루비 코드 분석 라이브러리는 적절한 코드 줄 수의 상한을 다음과 같이 판단.
        - 메서드 - 10줄 이내
        - 클래스 - 100줄 이내
    
    어떤 프로그래밍 언어를 사용하더라도, 이 정도가 적당하다고 한다.
    
    > 클래스를 분할하면 읽기 어려워질까?
    > 
    
    3장에서 ‘클래스 하나하나가 정상적으로 동작하도록 설계하는 것이 중요하다’고 얘기함.
    
    이런 관점에서, 분할된 로직이 신경 쓰이는 이유는 ‘분할된 클래스의 동작이 불안하기 때문’이다. ‘정상 동작하지 않을 것’이라고 생각하며 불안해할수록 즉 신뢰성이 낮을수록, 내부 로직이 신경 쓰이는 것.
    
    첨부터 내부 로직을 하나하나 신경 쓰지 않아도 되는 구조로 만들면 됨.
    
    ## 순환 복잡도
    
    → 코드의 구조적인 복잡함을 나타내는 지표
    
    | 순환 복잡도 | 복잡함의 상태 | 버그 확률 |
    | --- | --- | --- |
    | 10 이하 | 굉장히 좋은 구조 | 25% |
    | 30 이상 | 구조적인 리스크가 존재 | 40% |
    | 50 이상 | 테스트 불가능 | 70% |
    | 75 이상 | 변경할 때, 반드시 실수가 발생 | 98% |

조기 리턴, 전략 패턴, 일급 컬렉션 등의 테크닉을 활용하면 복잡도를 줄일 수 있다.

데이터 클래스는 로직이 따로 없으므로 복잡도 0

하지만 다른 클래스에 영향을 줄 수 있으므로 주의해야 한다.

순환 복잡도 10~15정도 나오면 좋음

## 응집도

→ 모듈 내부에서 데이터와 로직이 관련되어 있는 정도를 나타내는 지표

모듈은 클래스, 패키지, 레이어 등 다양하게 해석할 수 있다.

인스턴스 변수와 그 인스턴스 변수를 사용하는 로직이 같은 클래스에 구현되어 있으면 응집돠 높다고 할 수 있다.

응집도가 높을수록 변경 용이성이 높고 좋은 구조이다.

응집도를 나타내는 메트릭 : LCOM(Lack of Cohension in Methods)

## 결합도

모듈 간의 의존도를 나타내는 지표

= 어떤 클래스가 호출하는 다른 클래스의 수

결합도가 높을 수록 유지 보수, 사양 변경이 어렵다.

분석 도구를 사용해 계측 가능

## 청크

→ 기억할 수 있는 정보 덩어리의 단위

E.g) ‘hello’를 처음 배우는 사람은 이를 5-청크로 인식한다.

→ 반복 학습을 통해 1-청크로 인식

클래스를 설계할 때도 매지컬 넘버 4를 염두에 두고 뇌가 쉽게 받아들일 수 있는 구조인지 생각해보기.

클래스에서 다루는 개념이 4+-1개 정도가 되도록 설계하고, 이보다 큰 클래스는 작은 클래스로 분할 하기

단일 책임 원칙을 준수하면 매지컬 넘버에 맞출 수 있음

코드 분석 지원 도구

- 비주얼 스튜디오
    - 모든 라이선스 형태에서 코드 메트릭 계산 기능을 사용할 수 있음
    - 실행 가능한 코드의 줄 수, 복잡도

## 설계 대상과 비용 대비 효과

### 파레토의 법칙

매출의 80%는 전체 상품 중 20%의 상품이 만들어 낸다…

기능의 중요성, 사양 변경 빈도 모두 파레토의 법칙에 해당된다고 할 수 있다.

### 코어 도메인: 서비스의 중심 영역

모든 상품과 서비스는 이것이 우리가 판매하는 것이라고 말할 수 있는 중심 가치가 있다.

서비스에서 중심이 되는 비즈니스 영역을 <도메인 주도 설계>에서는 코어 도메인이라고 한다.

- 시스템에서 가장 큰 가치를 창출하는 곳
- 가치 있고 중요하고 비용 대비 효과가 가장 큰 곳
- 경쟁 우위에 있고, 차별점을 만들며 비즈니스 우위를 만들 수 있는 곳

## 중점 설계 대상 선정에는 비즈니스 지식이 필요하다

중요한 기능은 높은 빈도로 사양 변경이 일어나는 경향이 있따.

Code Climate Quality 같은 분석도구를 사용하면, 변경 빈도가 높은 곳을 찾을 수 있다.

도메인 전문가 : 사업 영역과 관련된 지식이 풍부한 사람

즉, 서비스와 관련된 비즈니스 지식이 필요하다.

# Question

## 응집도를 나타내는 메트릭 (LCOM)

응집도는 클래스의 내부 요소들이 얼마나 밀접하게 관련되어 있는지를 나타내며, lcom는 그 반대 개념으로서 응집도가 낮을수록 값이 높아진다.

메서드들이 서로 관련된 필드를 얼마나 공유하는지를 기반으로 계산된다

LCOM1=P-Q

P: 클래스 내에서 서로 다른 필드를 사용하는 메서드 쌍의 수

Q: 클래스 내에서 동이한 필드를 사용하는 메서드 쌍의 수

LCOM1이 양수인 경우 응집도가 낮으며, 0 또는 음수인 경우 응집도가 높은 것으로 평가한다

LCOM2 : LCOM1를 개선하여 클래스 내의 모든 메서드 쌍에 대한 필드 공유 여부를 평가하며, LCOM2 값이 1보다 크면 응집도가 낮다고 평가되며, 1 이해면 높은 응집도다.
